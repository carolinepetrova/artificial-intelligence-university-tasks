#include <algorithm>
#include <cmath>
#include <fstream>
#include <iostream>
#include <limits>
#include <random>
#include <sstream>
#include <unordered_map>

#include "input_parser.h"

/*
TODO SG:
Figure out a way to generate an image with colored clusters. If python is a good
tool for that, probably use this library https://github.com/pybind/pybind11 ?
*/

using namespace std;

template <typename Container>
void printContainer(const Container& container, ostream& logOs = cout) {
  for (const auto& element : container) {
    logOs << element << ' ';
  }
  logOs << endl;
}

namespace k_means {

using Centroid = Point;
using Centroids = vector<Centroid>;
using DataFrame = vector<Point>;
using Means = vector<Point>;
using PointIndexInDataFrame = int;

bool operator==(const Point& lhs, const Point& rhs) {
  return lhs.x == rhs.x && lhs.y == rhs.y;
}

namespace util {
double square(double value) { return value * value; }

double distance(Point p1, Point p2) {
  return sqrt(square(p1.x - p2.x) + square(p1.y - p2.y));
}

/**
 * @brief generate random integer between start and end, including both start
 * and end
 */
int generateRandomInteger(int start, int end) {
  static default_random_engine generator;
  uniform_int_distribution<int> distribution{start, end};
  return distribution(generator);
}

}  // namespace util

void initializeCentroidsRandomly(Centroids& centroids, long long from = 0,
                                 long long to = 999999);

vector<Point> findPointsBelongingToCentroid(
    const Centroid& centroid, const DataFrame& inputPoints,
    const unordered_map<PointIndexInDataFrame, Centroid>&
        mapPointIndexToCentroid);

Centroid findClosestCentroidForAPoint(const Point& point,
                                      const Centroids& centroids);

/**
 * Return a set of means for the given dataframe,
 * generated by the k-means algorithm
 */
Means k_means(long unsigned k, const DataFrame& inputPoints,
              int numberOfIterations = 100'000, ostream& logOs = cout) {
  logOs << "k_means() algorithm begins. Number of iterations = "
        << numberOfIterations << "\n";

  logOs << "Creating " << k << " centroids and initializing them randomly.\n";
  Centroids centroids{k};

  // Pick centroids as random points from the dataset.
  for (auto& centroid : centroids) {
    centroid = inputPoints[util::generateRandomInteger(0, inputPoints.size())];
  }

  // Assign to each point in the input dataframe a centroid (thus mapping each
  // point index to a centroid)
  unordered_map<PointIndexInDataFrame, Centroid> mapPointIndexToCentroid;

  logOs << "Begin of " << numberOfIterations << " iterations.\n";
  for (int iteration = 0; iteration < numberOfIterations; iteration++) {
    // logOs << "Printing centroids...\n";
    // printContainer(centroids, logOs);
    cout << iteration << '\n';

    // Assign to each point a centroid
    for (int pointIndex = 0; pointIndex < inputPoints.size(); ++pointIndex) {
      mapPointIndexToCentroid[pointIndex] =
          findClosestCentroidForAPoint(inputPoints[pointIndex], centroids);
      // logOs << "CLOSEST = " << mapPointIndexToCentroid[pointIndex] << '\n';
    }

    // Find the mean point for each centroid and assign to the centroid that
    // mean point
    for (auto& centroid : centroids) {
      Point meanPoint{0, 0};
      const auto pointsBelongingToCentroid = findPointsBelongingToCentroid(
          centroid, inputPoints, mapPointIndexToCentroid);

      for (const auto& point : pointsBelongingToCentroid) {
        meanPoint.x += point.x;
        meanPoint.y += point.y;
      }

      meanPoint.x =
          meanPoint.x / max<size_t>(pointsBelongingToCentroid.size(), 1);
      meanPoint.y =
          meanPoint.y / max<size_t>(pointsBelongingToCentroid.size(), 1);

      centroid = meanPoint;
    }
  }
  logOs << "End of " << numberOfIterations << " iterations.\n";

  return centroids;
}

vector<Point> findPointsBelongingToCentroid(
    const Centroid& centroid, const DataFrame& inputPoints,
    const unordered_map<PointIndexInDataFrame, Centroid>&
        mapPointIndexToCentroid) {
  vector<Point> result;
  for (int pointIndex = 0; pointIndex < inputPoints.size(); ++pointIndex) {
    if (mapPointIndexToCentroid.at(pointIndex) == centroid) {
      result.push_back(inputPoints[pointIndex]);
    }
  }
  return result;
}

Centroid findClosestCentroidForAPoint(const Point& point,
                                      const Centroids& centroids) {
  if (centroids.empty()) {
    throw "No centroids!";
  }

  double minDistance = numeric_limits<double>::max();
  Centroid closestCentroid = centroids[0];
  for (const Centroid& centroid : centroids) {
    double distanceToCentroid = util::distance(point, centroid);
    if (distanceToCentroid < minDistance) {
      minDistance = distanceToCentroid;
      closestCentroid = centroid;
    }
  }
  return closestCentroid;
}

};  // namespace k_means

void simpleTest(ostream& logOs = cout) {
  auto means = k_means::k_means(3, {{0, 0},
                                    {1, 1},
                                    {1000, 1000},
                                    {1001, 1001},
                                    {50000, 50000},
                                    {60000, 60000}});

  logOs << "Means generated by algorithm:\n";
  for (const auto& mean : means) {
    logOs << "(" << mean.x << ", " << mean.y << ")\n";
  }
}

void testInputParser(ostream& logOs = cout) {
  logOs << "testInputParser()\n";
  std::string test = "23.45 40.53 23.44 60.69";
  std::stringstream ss{test};

  auto points = k_means::input_parse::parse(ss);

  for (const auto& point : points) {
    logOs << point << " ";
  }
  logOs << endl;
}

void testNormalDataset(ostream& logOs = cout) {
  const std::string NORMAL_DATASET_FILE = "datasets/normal/normal.txt";
  const int k = 4;

  ifstream ifs{NORMAL_DATASET_FILE};

  const auto points = k_means::input_parse::parse(ifs);
  const auto means = k_means::k_means(k, points, 500, logOs);

  logOs << "Generated means by k-means algorithm:\n";
  for (const auto& mean : means) {
    logOs << mean << ' ';
  }
  logOs << endl;

  auto getMeanId = [&means](k_means::Centroid mean) {
    for (int i = 0; i < means.size(); i++) {
      if (means[i] == mean) return i;
    }
    throw "Mean is not in the vector of means!";
  };

  ofstream ofs{"normal_output.txt"};
  for (const auto& point : points) {
    auto cluster = k_means::findClosestCentroidForAPoint(point, means);
    ofs << point.x << "\t" << point.y << "\t" << getMeanId(cluster) << '\n';
  }
}

void testUnbalancedDataset(ostream& logOs = cout) {
  const std::string UNBALANCE_DATASET_FILE = "datasets/unbalance/unbalance.txt";
  const int k = 8;

  ifstream ifs{UNBALANCE_DATASET_FILE};

  const auto points = k_means::input_parse::parse(ifs);
  const auto means = k_means::k_means(k, points, 500, logOs);

  logOs << "Generated means by k-means algorithm:\n";
  for (const auto& mean : means) {
    logOs << mean << ' ';
  }
  logOs << endl;

  auto getMeanId = [&means](k_means::Centroid mean) {
    for (int i = 0; i < means.size(); i++) {
      if (means[i] == mean) return i;
    }
    throw "Mean is not in the vector of means!";
  };

  ofstream ofs{"unbalanced_output.txt"};
  for (const auto& point : points) {
    auto cluster = k_means::findClosestCentroidForAPoint(point, means);
    ofs << point.x << "\t" << point.y << "\t" << getMeanId(cluster) << '\n';
  }
}

int main() {
  // simpleTest();
  // testInputParser();

  ofstream ofs_normal{"normal_log.txt"};
  if (!ofs_normal) {
    throw "Could not open 'normal_log.txt'";
  }

  ofstream ofs_unbalanced{"unbalanced_log.txt"};
  if (!ofs_unbalanced) {
    throw "Could not open 'unbalanced_log.txt'";
  }

  testNormalDataset(ofs_normal);
  testUnbalancedDataset(ofs_unbalanced);
}