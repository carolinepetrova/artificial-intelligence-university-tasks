#ifndef NODE_H
#define NODE_H

#include <memory>
#include <unordered_map>
#include <variant>

#include "entries.h"
#include "utils.h"

namespace id3 {

using namespace std;

class Node {
 private:
  /**
   * The data for the id3 algorithm on each tree node; if
   * the node is leaf, the entries will be 0
   */
  Entries m_Entries;

  /**
   * ID3 Decision tree:
   * If the node is leaf, it will contain class (the decision)
   * If the node is not leaf, it will containt an attribute
   */
  variant<AttributeId, Class> m_value;

  const bool m_bIsLeaf;

  /**
   * Map all attribute values to child nodes
   *
   * If the node is leaf then it will not contain any child nodes, and the map
   * will be empty
   */
  unordered_map<AttributeValue, shared_ptr<Node>> m_mapChildren;

 public:
  /**
   * Creates non-leaf node containing entries for the ID3 algorithm to work on
   */
  explicit Node(const Entries& entries);

  /**
   * Creates a leaf node containing a class (the decision itself in ID3)
   */
  explicit Node(Class cl);

  bool isLeaf() const;

  variant<AttributeId, Class> getValue() const;

  /**
   * @brief Generates children for itself based on the entries and attribute it
   * contains
   *
   * Most of the children will contain entries which are subsets of current
   * entries. The subset will be generated by filtering specific attribute
   * values, as per ID3 algorithm. Some children however will be leaf nodes -
   * containing decision classes.
   *
   * @throw - throws exception if the node is leaf - cannot have any children
   */
  void generateChildren();

  vector<shared_ptr<Node>> getChildren();

  Entries getEntries() const;
};

}  // namespace id3

#endif